\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{fullpage}

\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{siunitx}

\usepackage[colorlinks=false,pdfborder={0 0 0}]{hyperref}
\usepackage[all]{hypcap}


\title{Astro 585: HW 6}
\author{Codename: The Maxwell-JÃ¼ttner Distribution}



\begin{document}


\maketitle

My git repository is here: \url{https://github.com/hsgg/astro585}, clone URL
\url{https://github.com/hsgg/astro585.git}.


\section{Parallel stuff}

1a) nprocs() is one larger than nworkers(). So there seems to be one process
that manages all the ones that will do the actual computation.

1b) As you told us, the functions are only defined on the main process, not the
workers.

1c) Presumably every worker writes to their own copy of 'integral', and the
main thread doesn't do anything, so 'integral' in the main thread remains 0.0.

pmap(): Looks like the main process is using one thread (ca~95\%), the other
two share the other one, but they don't use as much (ca 40\% each).

map(): Uses only one processor at a time. That's strange. The distributed array
seems to make it really slow. Not distributing makes the operation finish in
much less than a second, rather than 10s.

OK, I am not yet convinced of distributed arrays, although it seems to make
sense. There is significant overhead involved with this.

\section{Kepler}

185~seconds when running in serial. Oddly, my plot looks differnt than yours
when running your code:
\begin{center}
	\includegraphics[width=0.7\textwidth]{parameterspace_originalserial.pdf}
\end{center}

101~seconds in parallel, so slightly more than half the time, with almost the
same result. There is a difference close to (0.0,~0.0). Not good.
\begin{center}
	\includegraphics[width=0.7\textwidth]{parameterspace_parallel.pdf}
\end{center}


\end{document}
